module.exports = {
  /**
   * Extension (not real part of the spec but nice to have for vert.x)
   * @param {object} obj native vert.x object
   * @return wrapper function that follows the promise flow.
   */
  promisify: function promisify(obj) {
    if (typeof obj === 'function') {
      return function () {
        var args = [obj].concat(Array.prototype.slice.call(arguments));
        return new Promise(function (resolve, reject) {
          args.push(function (err, res) {
            if (err) {
              reject(err);
            } else {
              resolve(res);
            }
          });
          Function.call.apply(obj, args);
        });
      }
    } else if (typeof obj === 'object') {
      switch (process.engine) {
        case 'Nashorn':
          return {
            __noSuchMethod__: function () {
              var fn = arguments[0];
              var args = [obj].concat(Array.prototype.slice.call(arguments, 1));

              return new Promise(function (resolve, reject) {
                args.push(function (res) {
                  if (res.failed()) {
                    reject(res.cause());
                  } else {
                    resolve(res.result());
                  }
                });
                Function.call.apply(obj[fn], args);
              });
            }
          };
        case 'GraalVM':
          var o = {};
          for (let m in obj) {
            // capture the method
            let fn = obj[m];

            o[m] = function () {
              let args = [obj].concat(Array.prototype.slice.call(arguments));
              return new Promise(function (resolve, reject) {
                args.push(function (res) {
                  if (res.failed()) {
                    reject(res.cause());
                  } else {
                    resolve(res.result());
                  }
                });
                Function.call.apply(fn, args);
              });
            }
          }
          return o;
      }
    }
  }
};
